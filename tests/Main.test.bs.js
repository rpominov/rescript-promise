// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var $$Promise = require("../Promise.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

test("Promise.make", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.make(function (resolve) {
                        return Curry._1(resolve, 10);
                      }), (function (x) {
                      expect(x).toEqual(10);
                      
                    }));
      }));

test("Promise.make + nested promise", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.$$catch($$Promise.make(function (resolve) {
                            return Curry._1(resolve, $$Promise.resolve(10));
                          }), (function (exn) {
                          if (exn.RE_EXN_ID === Js_exn.$$Error) {
                            return {
                                    TAG: /* Ok */0,
                                    _0: exn._1.message
                                  };
                          } else {
                            return {
                                    TAG: /* Error */1,
                                    _0: "Didn't throw a correct exception"
                                  };
                          }
                        })), (function (result) {
                      expect(result).toEqual({
                            TAG: /* Error */1,
                            _0: {
                              TAG: /* Ok */0,
                              _0: "Cannot create a Promise containing another Promise as this will break ReScript static types"
                            }
                          });
                      
                    }));
      }));

test("Promise.resolve", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.resolve(10), (function (x) {
                      expect(x).toEqual(10);
                      
                    }));
      }));

test("Promise.resolve + nested promise", (function () {
        expect.assertions(1);
        var nestedPromise = $$Promise.resolve(10);
        var result;
        try {
          $$Promise.resolve(nestedPromise);
          result = {
            TAG: /* Error */1,
            _0: "Didn't throw"
          };
        }
        catch (raw_err){
          var err = Caml_js_exceptions.internalToOCamlException(raw_err);
          result = err.RE_EXN_ID === Js_exn.$$Error ? ({
                TAG: /* Ok */0,
                _0: err._1.message
              }) : ({
                TAG: /* Error */1,
                _0: "Didn't throw a correct exception"
              });
        }
        expect(result).toEqual({
              TAG: /* Ok */0,
              _0: "Cannot create a Promise containing another Promise as this will break ReScript static types"
            });
        
      }));

test("Promise.reject / Promise.catch", (function () {
        expect.assertions(1);
        var err = $$Promise.makeJsError("Test");
        return $$Promise.map($$Promise.$$catch($$Promise.reject(err), (function (x) {
                          return x;
                        })), (function (x) {
                      if (x.TAG === /* Ok */0) {
                        return Js_exn.raiseError("Should not happen");
                      }
                      var e = x._0;
                      if (e.RE_EXN_ID === Js_exn.$$Error) {
                        expect(e._1).toBe(err);
                        return ;
                      } else {
                        return Js_exn.raiseError("Should not happen");
                      }
                    }));
      }));

test("Promise.race", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.race([
                        $$Promise.resolve(1),
                        $$Promise.resolve(1)
                      ]), (function (x) {
                      expect(x).toEqual(1);
                      
                    }));
      }));

test("Promise.all", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all([
                        $$Promise.resolve(1),
                        $$Promise.resolve(2)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            2
                          ]);
                      
                    }));
      }));

test("Promise.all2", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all2([
                        $$Promise.resolve(1),
                        $$Promise.resolve(true)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            true
                          ]);
                      
                    }));
      }));

test("Promise.all3", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all3([
                        $$Promise.resolve(1),
                        $$Promise.resolve(true),
                        $$Promise.resolve(2)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            true,
                            2
                          ]);
                      
                    }));
      }));

test("Promise.all4", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all4([
                        $$Promise.resolve(1),
                        $$Promise.resolve(true),
                        $$Promise.resolve(2),
                        $$Promise.resolve(3)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            true,
                            2,
                            3
                          ]);
                      
                    }));
      }));

test("Promise.all5", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all5([
                        $$Promise.resolve(1),
                        $$Promise.resolve(true),
                        $$Promise.resolve(2),
                        $$Promise.resolve(3),
                        $$Promise.resolve(4)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            true,
                            2,
                            3,
                            4
                          ]);
                      
                    }));
      }));

test("Promise.all6", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.all6([
                        $$Promise.resolve(1),
                        $$Promise.resolve(true),
                        $$Promise.resolve(2),
                        $$Promise.resolve(3),
                        $$Promise.resolve(4),
                        $$Promise.resolve(5)
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            true,
                            2,
                            3,
                            4,
                            5
                          ]);
                      
                    }));
      }));

test("Promise.chain", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.chain($$Promise.resolve(1), (function (x) {
                          return $$Promise.resolve(x + 1 | 0);
                        })), (function (x) {
                      expect(x).toEqual(2);
                      
                    }));
      }));

test("Promise.map", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.map($$Promise.resolve(1), (function (x) {
                          return x + 1 | 0;
                        })), (function (x) {
                      expect(x).toEqual(2);
                      
                    }));
      }));

test("Promise.done", (function (testDone) {
        expect.assertions(1);
        return $$Promise.done($$Promise.resolve(1), (function (x) {
                      expect(x).toEqual(1);
                      return testDone();
                    }));
      }));

test("Promise.chainOk + Error", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.chainOk($$Promise.resolve({
                            TAG: /* Error */1,
                            _0: 1
                          }), (function (x) {
                          return $$Promise.resolve({
                                      TAG: /* Ok */0,
                                      _0: x + 1 | 0
                                    });
                        })), (function (x) {
                      expect(x).toEqual({
                            TAG: /* Error */1,
                            _0: 1
                          });
                      
                    }));
      }));

test("Promise.chainOk + Ok", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.chainOk($$Promise.resolve({
                            TAG: /* Ok */0,
                            _0: 1
                          }), (function (x) {
                          return $$Promise.resolve({
                                      TAG: /* Ok */0,
                                      _0: x + 1 | 0
                                    });
                        })), (function (x) {
                      expect(x).toEqual({
                            TAG: /* Ok */0,
                            _0: 2
                          });
                      
                    }));
      }));

test("Promise.mapOk + Error", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.mapOk($$Promise.resolve({
                            TAG: /* Error */1,
                            _0: 1
                          }), (function (x) {
                          return {
                                  TAG: /* Ok */0,
                                  _0: x + 1 | 0
                                };
                        })), (function (x) {
                      expect(x).toEqual({
                            TAG: /* Error */1,
                            _0: 1
                          });
                      
                    }));
      }));

test("Promise.mapOk + Ok", (function () {
        expect.assertions(1);
        return $$Promise.map($$Promise.mapOk($$Promise.resolve({
                            TAG: /* Ok */0,
                            _0: 1
                          }), (function (x) {
                          return {
                                  TAG: /* Ok */0,
                                  _0: x + 1 | 0
                                };
                        })), (function (x) {
                      expect(x).toEqual({
                            TAG: /* Ok */0,
                            _0: 2
                          });
                      
                    }));
      }));

test("Promise.sequence", (function () {
        expect.assertions(2);
        var events = [];
        return $$Promise.map($$Promise.sequence([
                        (function (param) {
                            events.push("first fn called");
                            return $$Promise.map($$Promise.resolve(undefined), (function (param) {
                                          events.push("first resolved");
                                          return 1;
                                        }));
                          }),
                        (function (param) {
                            events.push("second fn called");
                            return $$Promise.map($$Promise.resolve(undefined), (function (param) {
                                          events.push("second resolved");
                                          return 2;
                                        }));
                          }),
                        (function (param) {
                            events.push("third fn called");
                            return $$Promise.map($$Promise.resolve(undefined), (function (param) {
                                          events.push("third resolved");
                                          return 3;
                                        }));
                          })
                      ]), (function (x) {
                      expect(x).toEqual([
                            1,
                            2,
                            3
                          ]);
                      expect(events).toEqual([
                            "first fn called",
                            "first resolved",
                            "second fn called",
                            "second resolved",
                            "third fn called",
                            "third resolved"
                          ]);
                      
                    }));
      }));

/*  Not a pure module */
