// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Process = require("process");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var NestedPromise = /* @__PURE__ */Caml_exceptions.create("Promise.NestedPromise");

var isPromiseLike = ((obj) => obj != null && typeof obj.then === 'function');

function resolve(x) {
  if (isPromiseLike(x)) {
    throw {
          RE_EXN_ID: NestedPromise,
          rescripMessage: "Cannot create a Promise containing another Promise as this will break ReScript static types",
          nestedPromise: x,
          Error: new Error()
        };
  }
  return Promise.resolve(x);
}

function make(fn) {
  return new Promise((function (resolve) {
                return Curry._1(fn, (function (x) {
                              if (isPromiseLike(x)) {
                                throw {
                                      RE_EXN_ID: NestedPromise,
                                      rescripMessage: "Cannot create a Promise containing another Promise as this will break ReScript static types",
                                      nestedPromise: x,
                                      Error: new Error()
                                    };
                              }
                              return resolve(x);
                            }));
              }));
}

function $$catch(promise, fn) {
  return promise.then((function (x) {
                return resolve({
                            TAG: /* Ok */0,
                            _0: x
                          });
              }), (function (e) {
                return resolve({
                            TAG: /* Error */1,
                            _0: Curry._1(fn, Js_exn.anyToExnInternal(e))
                          });
              }));
}

function chain(promise, fn) {
  return promise.then(Curry.__1(fn), undefined);
}

function map(promise, fn) {
  return promise.then((function (x) {
                return resolve(Curry._1(fn, x));
              }), undefined);
}

function crash(exn) {
  console.error("Unrecoverable Promise rejection!");
  if (exn.RE_EXN_ID === Js_exn.$$Error) {
    console.error(exn._1);
  } else {
    console.error(exn);
  }
  return Process.exit(1);
}

function done(promise, fn) {
  promise.then((function (x) {
          try {
            Curry._1(fn, x);
            return resolve(undefined);
          }
          catch (raw_exn){
            return crash(Caml_js_exceptions.internalToOCamlException(raw_exn));
          }
        }), (function (e) {
          return crash(Js_exn.anyToExnInternal(e));
        }));
  
}

function chainOk(promise, fn) {
  return chain(promise, (function (val) {
                if (val.TAG === /* Ok */0) {
                  return Curry._1(fn, val._0);
                } else {
                  return resolve({
                              TAG: /* Error */1,
                              _0: val._0
                            });
                }
              }));
}

function mapOk(promise, fn) {
  return chainOk(promise, (function (val) {
                return resolve(Curry._1(fn, val));
              }));
}

function mergeErrors(promise) {
  return chain(promise, (function (res) {
                var tmp;
                if (res.TAG === /* Ok */0) {
                  var e = res._0;
                  tmp = e.TAG === /* Ok */0 ? ({
                        TAG: /* Ok */0,
                        _0: e._0
                      }) : ({
                        TAG: /* Error */1,
                        _0: e._0
                      });
                } else {
                  tmp = {
                    TAG: /* Error */1,
                    _0: res._0
                  };
                }
                return resolve(tmp);
              }));
}

function sequence(arr) {
  var helper = function (result, i) {
    if (i === arr.length) {
      return result;
    } else {
      return chain(result, (function (r) {
                    return helper(chain(Curry._1(Caml_array.get(arr, i), undefined), (function (x) {
                                      return resolve(r.concat([x]));
                                    })), i + 1 | 0);
                  }));
    }
  };
  return helper(resolve([]), 0);
}

function reject(prim) {
  return Promise.reject(prim);
}

function race(prim) {
  return Promise.race(prim);
}

function all(prim) {
  return Promise.all(prim);
}

function all2(prim) {
  return Promise.all(prim);
}

function all3(prim) {
  return Promise.all(prim);
}

function all4(prim) {
  return Promise.all(prim);
}

function all5(prim) {
  return Promise.all(prim);
}

function all6(prim) {
  return Promise.all(prim);
}

exports.NestedPromise = NestedPromise;
exports.resolve = resolve;
exports.reject = reject;
exports.race = race;
exports.all = all;
exports.all2 = all2;
exports.all3 = all3;
exports.all4 = all4;
exports.all5 = all5;
exports.all6 = all6;
exports.make = make;
exports.$$catch = $$catch;
exports.chain = chain;
exports.map = map;
exports.done = done;
exports.chainOk = chainOk;
exports.mapOk = mapOk;
exports.mergeErrors = mergeErrors;
exports.sequence = sequence;
/* process Not a pure module */
